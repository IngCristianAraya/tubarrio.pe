'use client';

import * as React from 'react';
const { createContext, useState, useEffect, useMemo } = React;
import { 
  User, 
  onAuthStateChanged,
  signInWithEmailAndPassword as firebaseSignIn,
  signOut as firebaseSignOut,
  sendPasswordResetEmail as firebaseSendPasswordResetEmail,
  Auth,
  AuthError,
  AuthErrorCodes
} from 'firebase/auth';
import { FirebaseError } from 'firebase/app';
import { auth as firebaseAuth, initializeFirebase } from '@/lib/firebase/config';
import { toast } from 'react-hot-toast';

// Definir los tipos necesarios
interface AuthContextType {
  user: User | null;
  loading: boolean;
  isAuthenticated: boolean;
  error: Error | null;
  signIn: (email: string, password: string) => Promise<User>;
  signOut: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
}

// Crear el contexto con un valor por defecto
const AuthContext = React.createContext<AuthContextType | undefined>(undefined);

// Get auth instance with lazy initialization
const getAuthInstance = (): Auth | null => {
  if (typeof window === 'undefined') {
    console.log('Skipping Firebase Auth initialization during SSR');
    return null;
  }
  
  console.log('üîß Initializing Firebase Auth...');
  
  try {
    // Log environment variables (redacted for security)
    console.log('üîß Firebase Config:', {
      hasApiKey: !!process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
      authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
      projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
      appId: !!process.env.NEXT_PUBLIC_FIREBASE_APP_ID
    });
    
    // Ensure Firebase is initialized
    console.log('üîß Initializing Firebase...');
    initializeFirebase();
    
    // Get the Firebase Auth instance
    const authInstance = firebaseAuth?.instance;
    console.log('üîß Firebase Auth instance:', authInstance ? '‚úÖ Success' : '‚ùå Failed');
    
    return authInstance || null;
  } catch (error) {
    console.error('‚ùå Error initializing Firebase Auth:', error);
    return null;
  }
  
  return context;
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = React.useState<User | null>(null);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<Error | null>(null);
  const isAuthenticated = !!user;

  // Inicializar Firebase Auth
  const auth = React.useMemo<Auth | null>(() => {
    try {
      const { auth: firebaseAuthInstance } = initializeFirebase();
      return firebaseAuthInstance || null;
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error initializing Firebase');
      console.error('Error initializing Firebase:', error);
      setError(error);
      return null;
    }
  }, []);

  // Configurar el observador de estado de autenticaci√≥n
  React.useEffect(() => {
    if (!auth) return;

    console.log('üë§ Setting up auth state observer...');
    setLoading(true);
    
    const unsubscribe = onAuthStateChanged(
      auth,
      (user) => {
        console.log('üë§ Auth state changed:', user ? 'User signed in' : 'No user');
        setUser(user);
        setError(null);
        setLoading(false);
      },
      (error) => {
        console.error('‚ùå Auth state observer error:', error);
        setError(error);
        setLoading(false);
      }
    );
    
    // Limpieza al desmontar
    return () => {
      console.log('üëã Cleaning up auth observer');
      unsubscribe();
    };
  }, [auth]);

  // Funci√≥n para iniciar sesi√≥n
  const signIn = async (email: string, password: string): Promise<User> => {
    if (!auth) throw new Error('Firebase Auth no est√° disponible');
    
    try {
      setLoading(true);
      setError(null);
      
      const userCredential = await firebaseSignIn(auth, email, password);
      toast.success('Inicio de sesi√≥n exitoso');
      return userCredential.user;
    } catch (err) {
      const error = err as AuthError;
      let errorMessage = 'Error al iniciar sesi√≥n';
      
      if (error.code === AuthErrorCodes.INVALID_EMAIL) {
        errorMessage = 'Correo electr√≥nico inv√°lido';
      } else if (error.code === AuthErrorCodes.USER_DELETED || error.code === AuthErrorCodes.INVALID_PASSWORD) {
        errorMessage = 'Correo o contrase√±a incorrectos';
      } else if (error.code === AuthErrorCodes.TOO_MANY_ATTEMPTS_TRY_LATER) {
        errorMessage = 'Demasiados intentos. Intente m√°s tarde';
      }
      
      toast.error(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  // Funci√≥n para cerrar sesi√≥n
  const signOut = async (): Promise<void> => {
    if (!auth) throw new Error('Firebase Auth no est√° disponible');
    
    try {
      setLoading(true);
      await firebaseSignOut(auth);
      toast.success('Sesi√≥n cerrada correctamente');
    } catch (err) {
      const error = err as Error;
      console.error('Error al cerrar sesi√≥n:', error);
      toast.error('Error al cerrar sesi√≥n');
      throw error;
    } finally {
      setLoading(false);
    }
  };

  // Funci√≥n para restablecer contrase√±a
  const resetPassword = async (email: string): Promise<void> => {
    if (!auth) throw new Error('Firebase Auth no est√° disponible');
    
    try {
      setLoading(true);
      setError(null);
      
      await firebaseSendPasswordResetEmail(auth, email);
      toast.success('Correo de recuperaci√≥n enviado');
    } catch (err) {
      const error = err as AuthError;
      let errorMessage = 'Error al enviar correo de recuperaci√≥n';
      
      if (error.code === AuthErrorCodes.INVALID_EMAIL) {
        errorMessage = 'Correo electr√≥nico inv√°lido';
      } else if (error.code === AuthErrorCodes.USER_DELETED) {
        errorMessage = 'No existe una cuenta con este correo electr√≥nico';
      }
      
      toast.error(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  // Valor del contexto
  const contextValue = React.useMemo<AuthContextType>(
    () => ({
      user,
      loading,
      isAuthenticated,
      error,
      signIn,
      signOut,
      resetPassword,
    }),
    [user, loading, isAuthenticated, error]
  );

  return (
    <AuthContext.Provider value={contextValue}>
      {!loading && children}
    </AuthContext.Provider>
  );
}

export default AuthContext;
