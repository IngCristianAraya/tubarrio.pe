'use client';

import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode, useMemo } from 'react';
import { collection, getDocs, getDoc, doc, query, where, orderBy, limit, DocumentData } from 'firebase/firestore';
import { db } from '@/lib/firebase/config';
import { toast } from 'react-hot-toast';

// Cache configuration
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
const MAX_CACHE_SIZE = 50; // Max number of services to cache

// Cache entry interface
interface CacheEntry<T> {
  data: T;
  timestamp: number;
}

// Verify Firestore initialization
if (process.env.NODE_ENV === 'development' && db) {
  console.log('Firestore initialized successfully');
}

if (!db) {
  const error = 'Firebase initialization failed. Please check your configuration.';
  console.error(error);
  throw new Error(error);
}

// Types
export interface Service {
  id: string;
  name: string;
  category: string;
  image: string;
  images?: string[];
  rating: number;
  location: string;
  description: string;
  contactUrl?: string;
  detailsUrl?: string;
  horario?: string;
  tags?: string[];
  hours?: string;
  social?: string;
  whatsapp?: string;
  active?: boolean;
}

interface ServicesContextType {
  services: Service[];
  filteredServices: Service[];
  featuredServices: Service[];
  loading: boolean;
  error: string | null;
  searchTerm: string;
  selectedCategory: string;
  categories: string[];
  isSearching: boolean;
  setSearchTerm: (term: string) => void;
  setSelectedCategory: (category: string) => void;
  getServiceById: (id: string) => Promise<Service | null>;
  searchServices: (query: string, category?: string) => void;
  resetSearch: () => void;
  refreshServices: () => Promise<void>;
}

const ServicesContext = createContext<ServicesContextType | undefined>(undefined);

// Cache implementation
class ServiceCache<T> {
  private cache: Map<string, CacheEntry<T>>;
  private maxSize: number;
  private cacheDuration: number;
  
  constructor(maxSize: number = MAX_CACHE_SIZE, cacheDuration: number = CACHE_DURATION) {
    this.cache = new Map<string, CacheEntry<T>>();
    this.maxSize = maxSize;
    this.cacheDuration = cacheDuration;
  }

  get(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;
    
    // Check if cache entry is still valid
    if (Date.now() - entry.timestamp > this.cacheDuration) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.data;
  }

  set(key: string, data: T): void {
    // Enforce max cache size
    if (this.cache.size >= this.maxSize) {
      // Delete the oldest entry
      const oldestEntry = this.cache.entries().next();
      if (!oldestEntry.done) {
        const [oldestKey] = oldestEntry.value;
        this.cache.delete(oldestKey);
      }
    }
    
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  clear(): void {
    this.cache.clear();
  }

  // Clean up expired entries
  cleanup(): void {
    const now = Date.now();
    Array.from(this.cache.entries()).forEach(([key, entry]) => {
      if (now - entry.timestamp > this.cacheDuration) {
        this.cache.delete(key);
      }
    });
  }
}

// Initialize cache
const cache = new ServiceCache<Service | Service[]>();

interface ServicesProviderProps {
  children: ReactNode;
}

export const ServicesProvider: React.FC<ServicesProviderProps> = ({ children }) => {
  // State management
  const [state, setState] = useState({
    services: [] as Service[],
    filteredServices: [] as Service[],
    featuredServices: [] as Service[],
    categories: [] as string[],
    loading: true,
    error: null as string | null,
    searchTerm: '',
    selectedCategory: '',
    isSearching: false
  });

  // Destructure state for easier access
  const {
    services,
    filteredServices,
    featuredServices,
    loading,
    error: stateError,
    searchTerm,
    selectedCategory,
    categories,
    isSearching
  } = state;
  
  // Helper function to update state
  const updateState = useCallback((updates: Partial<typeof state>) => {
    setState(prev => ({ ...prev, ...updates }));
  }, []);

  // Update categories from services
  const updateCategories = useCallback((servicesData: Service[]) => {
    try {
      const uniqueCategories = Array.from(
        new Set(servicesData.map(service => service.category).filter(Boolean))
      ) as string[];
      updateState({ categories: uniqueCategories });
    } catch (error) {
      console.error('Error updating categories:', error);
      updateState({ error: 'Failed to update categories' });
    }
  }, [updateState]);

  // Load featured services
  const loadFeaturedServices = useCallback(async (servicesData?: Service[]) => {
    try {
      const cacheKey = 'featured-services';
      const cached = cache.get(cacheKey) as Service[] | null;
      
      if (cached) {
        updateState({ featuredServices: cached });
        return;
      }
      
      let featured: Service[] = [];
      if (servicesData) {
        // Filter featured services from provided data
        featured = servicesData.filter(service => 
          service.tags?.includes('featured') && service.active !== false
        );
      } else {
        // Fetch from Firestore if no data provided
        const featuredQuery = query(
          collection(db, 'services'),
          where('tags', 'array-contains', 'featured'),
          where('active', '==', true),
          limit(6)
        );
        
        const querySnapshot = await getDocs(featuredQuery);
        featured = querySnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        } as Service));
      }
      
      // Update cache and state
      cache.set(cacheKey, featured);
      updateState({ featuredServices: featured });
    } catch (error) {
      console.error('Error loading featured services:', error);
      updateState({ error: 'Failed to load featured services' });
      toast.error('Error al cargar los servicios destacados');
    }
  }, [updateState]);

  // Load all services
  const loadServices = useCallback(async (forceRefresh = false) => {
    try {
      updateState({ loading: true, error: null });
      
      const cacheKey = 'all-services';
      const cached = !forceRefresh ? cache.get(cacheKey) as Service[] | null : null;
      
      if (cached) {
        updateState({ 
          services: cached,
          filteredServices: cached,
          loading: false 
        });
        updateCategories(cached);
        await loadFeaturedServices(cached);
        return;
      }
      
      // Fetch from Firestore
      const servicesQuery = query(
        collection(db, 'services'),
        where('active', '==', true),
        orderBy('name')
      );
      
      const querySnapshot = await getDocs(servicesQuery);
      const servicesData = querySnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      } as Service));
      
      // Cache the results
      cache.set(cacheKey, servicesData);
      
      updateState({ 
        services: servicesData,
        filteredServices: servicesData,
        loading: false 
      });
      
      updateCategories(servicesData);
      await loadFeaturedServices(servicesData);
    } catch (error) {
      console.error('Error loading services:', error);
      updateState({ 
        loading: false, 
        error: 'Failed to load services. Please try again later.' 
      });
      toast.error('Error al cargar los servicios. Por favor, inténtalo de nuevo.');
    }
  }, [updateState, updateCategories, loadFeaturedServices]);

  // Load services on component mount
  useEffect(() => {
    loadServices();
  }, [loadServices]);

  // Get service by ID
  const getServiceById = useCallback(async (id: string): Promise<Service | null> => {
    try {
      const cacheKey = `service-${id}`;
      const cached = cache.get(cacheKey) as Service | null;
      
      if (cached) {
        return cached;
      }
      
      const docRef = doc(db, 'services', id);
      const docSnap = await getDoc(docRef);
      
      if (docSnap.exists()) {
        const serviceData = { 
          id: docSnap.id, 
          ...docSnap.data() 
        } as Service;
        cache.set(cacheKey, serviceData);
        return serviceData;
      }
      
      return null;
    } catch (error) {
      console.error('Error getting service by ID:', error);
      toast.error('Error al cargar el servicio. Por favor, inténtalo de nuevo.');
      return null;
    }
  }, []);

  // Search services
  const searchServices = useCallback((searchQuery: string, category: string = '') => {
    updateState({ 
      isSearching: true, 
      searchTerm: searchQuery, 
      selectedCategory: category 
    });
    
    let results = [...state.services];
    
    // Filter by search term
    if (searchQuery) {
      const searchLower = searchQuery.toLowerCase();
      results = results.filter(service => 
        service.name.toLowerCase().includes(searchLower) ||
        service.description?.toLowerCase().includes(searchLower) ||
        service.category.toLowerCase().includes(searchLower) ||
        service.tags?.some(tag => tag.toLowerCase().includes(searchLower))
      );
    }
    
    // Filter by category
    if (category) {
      results = results.filter(service => service.category === category);
    }
    
    updateState({ filteredServices: results });
  }, [state.services, updateState]);

  // Reset search
  const resetSearch = useCallback(() => {
    updateState({
      searchTerm: '',
      selectedCategory: '',
      filteredServices: state.services,
      isSearching: false
    });
  }, [state.services, updateState]);

  // Set search term
  const setSearchTerm = useCallback((term: string) => {
    updateState({ searchTerm: term });
  }, [updateState]);

  // Set selected category
  const setSelectedCategory = useCallback((category: string) => {
    updateState({ selectedCategory: category });
  }, [updateState]);

  // Refresh services
  const refreshServices = useCallback(async () => {
    await loadServices(true);
  }, [loadServices]);

  // Context value
  const contextValue = useMemo(() => ({
    services,
    filteredServices,
    featuredServices,
    loading,
    error: stateError,
    searchTerm,
    selectedCategory,
    categories,
    isSearching,
    setSearchTerm,
    setSelectedCategory,
    getServiceById,
    searchServices,
    resetSearch,
    refreshServices
  }), [
    services,
    filteredServices,
    featuredServices,
    loading,
    stateError,
    searchTerm,
    selectedCategory,
    categories,
    isSearching,
    setSearchTerm,
    setSelectedCategory,
    getServiceById,
    searchServices,
    resetSearch,
    refreshServices
  ]);

  return (
    <ServicesContext.Provider value={contextValue}>
      {children}
    </ServicesContext.Provider>
  );
};

// Custom hook to use the services context
export const useServices = (): ServicesContextType => {
  const context = useContext(ServicesContext);
  if (context === undefined) {
    throw new Error('useServices must be used within a ServicesProvider');
  }
  return context;
};

export default ServicesContext;
