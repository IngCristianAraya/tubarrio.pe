/**
 * Demostraci√≥n del impacto de las optimizaciones implementadas
 * Simula el comportamiento sin conexi√≥n real a Firebase
 */

const fs = require('fs');

// Simulador de lecturas de Firestore
class FirestoreSimulator {
  constructor() {
    this.readCount = 0;
    this.operations = [];
  }
  
  // Simular getDocs (m√©todo anterior)
  async getDocs(collectionName, limit = null) {
    const count = limit || 100; // Sin l√≠mite, carga todos
    this.readCount += count;
    this.operations.push({
      operation: 'getDocs',
      collection: collectionName,
      reads: count,
      timestamp: Date.now()
    });
    
    console.log(`üìä getDocs(${collectionName}): +${count} lecturas`);
    
    // Simular delay de red
    await new Promise(resolve => setTimeout(resolve, 200 + Math.random() * 300));
    
    return {
      docs: Array(count).fill(null).map((_, i) => ({
        id: `doc_${i}`,
        data: () => ({ name: `Servicio ${i}`, category: 'test' })
      }))
    };
  }
  
  // Simular getDoc (m√©todo optimizado)
  async getDoc(docId) {
    this.readCount += 1;
    this.operations.push({
      operation: 'getDoc',
      docId,
      reads: 1,
      timestamp: Date.now()
    });
    
    console.log(`üìä getDoc(${docId}): +1 lectura`);
    
    // Simular delay de red m√°s r√°pido
    await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 100));
    
    return {
      exists: () => true,
      id: docId,
      data: () => ({ name: `Servicio ${docId}`, category: 'test' })
    };
  }
  
  getStats() {
    return {
      totalReads: this.readCount,
      operations: this.operations,
      estimatedCost: (this.readCount * 0.00036).toFixed(4)
    };
  }
  
  reset() {
    this.readCount = 0;
    this.operations = [];
  }
}

// Simulador de localStorage con TTL
class CacheSimulator {
  constructor() {
    this.storage = {};
    this.hits = 0;
    this.misses = 0;
  }
  
  get(key, ttlMs = 3600000) { // 1 hora por defecto
    const item = this.storage[key];
    if (!item) {
      this.misses++;
      console.log(`‚ùå Cache MISS: ${key}`);
      return null;
    }
    
    if (Date.now() - item.timestamp > ttlMs) {
      delete this.storage[key];
      this.misses++;
      console.log(`‚è∞ Cache EXPIRED: ${key}`);
      return null;
    }
    
    this.hits++;
    console.log(`üéØ Cache HIT: ${key}`);
    return item.data;
  }
  
  set(key, data) {
    this.storage[key] = {
      data,
      timestamp: Date.now()
    };
    console.log(`üíæ Cache SET: ${key}`);
  }
  
  getStats() {
    const total = this.hits + this.misses;
    return {
      hits: this.hits,
      misses: this.misses,
      hitRate: total > 0 ? ((this.hits / total) * 100).toFixed(1) : '0.0',
      totalItems: Object.keys(this.storage).length
    };
  }
  
  clear() {
    this.storage = {};
    this.hits = 0;
    this.misses = 0;
  }
}

// Demostraci√≥n de escenarios
class OptimizationDemo {
  constructor() {
    this.firestore = new FirestoreSimulator();
    this.cache = new CacheSimulator();
  }
  
  // Escenario 1: M√©todo tradicional (sin optimizaciones)
  async scenarioTraditional() {
    console.log('\nüî¥ ESCENARIO 1: M√©todo Tradicional (SIN optimizaciones)');
    console.log('-'.repeat(60));
    
    this.firestore.reset();
    this.cache.clear();
    
    const startTime = Date.now();
    
    // Cargar p√°gina principal - todos los servicios
    console.log('üìÑ Cargando p√°gina principal...');
    await this.firestore.getDocs('services'); // 100 servicios
    
    // Usuario navega a servicios individuales
    console.log('\nüîç Usuario navega a servicios individuales...');
    for (let i = 0; i < 5; i++) {
      // Sin cache - cada visita requiere nueva consulta
      await this.firestore.getDocs('services', 1); // Buscar 1 servicio espec√≠fico
    }
    
    // Cargar servicios destacados
    console.log('\n‚≠ê Cargando servicios destacados...');
    await this.firestore.getDocs('services', 10);
    
    const endTime = Date.now();
    const stats = this.firestore.getStats();
    
    console.log('\nüìä RESULTADOS:');
    console.log(`  ‚è±Ô∏è  Tiempo total: ${endTime - startTime}ms`);
    console.log(`  üìà Total de lecturas: ${stats.totalReads}`);
    console.log(`  üí∞ Costo estimado: $${stats.estimatedCost} USD`);
    
    return {
      scenario: 'traditional',
      time: endTime - startTime,
      reads: stats.totalReads,
      cost: parseFloat(stats.estimatedCost)
    };
  }
  
  // Escenario 2: M√©todo optimizado
  async scenarioOptimized() {
    console.log('\nüü¢ ESCENARIO 2: M√©todo Optimizado (CON todas las optimizaciones)');
    console.log('-'.repeat(60));
    
    this.firestore.reset();
    this.cache.clear();
    
    const startTime = Date.now();
    
    // Cargar p√°gina principal - solo primera p√°gina (paginaci√≥n)
    console.log('üìÑ Cargando p√°gina principal (paginado)...');
    const mainServices = await this.firestore.getDocs('services', 20); // Solo 20 servicios
    this.cache.set('main_services_page_1', mainServices);
    
    // Cargar servicios destacados con cache
    console.log('\n‚≠ê Cargando servicios destacados...');
    let featuredServices = this.cache.get('featured_services');
    if (!featuredServices) {
      featuredServices = await this.firestore.getDocs('services', 6);
      this.cache.set('featured_services', featuredServices);
    }
    
    // Usuario navega a servicios individuales (con cache)
    console.log('\nüîç Usuario navega a servicios individuales...');
    const serviceIds = ['service_1', 'service_2', 'service_3', 'service_4', 'service_5'];
    
    for (const serviceId of serviceIds) {
      let service = this.cache.get(`service_${serviceId}`);
      if (!service) {
        service = await this.firestore.getDoc(serviceId); // getDoc en lugar de getDocs
        this.cache.set(`service_${serviceId}`, service);
      }
    }
    
    // Simular precarga inteligente
    console.log('\nüöÄ Precarga inteligente de servicios populares...');
    const popularServices = ['popular_1', 'popular_2', 'popular_3'];
    for (const serviceId of popularServices) {
      let service = this.cache.get(`service_${serviceId}`);
      if (!service) {
        service = await this.firestore.getDoc(serviceId);
        this.cache.set(`service_${serviceId}`, service);
      }
    }
    
    // Simular segunda visita del usuario (todo desde cache)
    console.log('\nüîÑ Usuario regresa - segunda visita...');
    for (const serviceId of serviceIds) {
      this.cache.get(`service_${serviceId}`); // Todo desde cache
    }
    
    const endTime = Date.now();
    const firestoreStats = this.firestore.getStats();
    const cacheStats = this.cache.getStats();
    
    console.log('\nüìä RESULTADOS:');
    console.log(`  ‚è±Ô∏è  Tiempo total: ${endTime - startTime}ms`);
    console.log(`  üìà Total de lecturas: ${firestoreStats.totalReads}`);
    console.log(`  üí∞ Costo estimado: $${firestoreStats.estimatedCost} USD`);
    console.log(`  üéØ Cache hit rate: ${cacheStats.hitRate}%`);
    console.log(`  üíæ Items en cache: ${cacheStats.totalItems}`);
    
    return {
      scenario: 'optimized',
      time: endTime - startTime,
      reads: firestoreStats.totalReads,
      cost: parseFloat(firestoreStats.estimatedCost),
      cacheHitRate: parseFloat(cacheStats.hitRate),
      cacheItems: cacheStats.totalItems
    };
  }
  
  // Comparaci√≥n y reporte
  generateComparisonReport(traditionalResult, optimizedResult) {
    const readsSaved = traditionalResult.reads - optimizedResult.reads;
    const costSaved = traditionalResult.cost - optimizedResult.cost;
    const timeSaved = traditionalResult.time - optimizedResult.time;
    
    const readsPercentage = ((readsSaved / traditionalResult.reads) * 100).toFixed(1);
    const costPercentage = ((costSaved / traditionalResult.cost) * 100).toFixed(1);
    const timePercentage = ((timeSaved / traditionalResult.time) * 100).toFixed(1);
    
    return {
      traditional: traditionalResult,
      optimized: optimizedResult,
      savings: {
        reads: readsSaved,
        cost: costSaved,
        time: timeSaved,
        readsPercentage: parseFloat(readsPercentage),
        costPercentage: parseFloat(costPercentage),
        timePercentage: parseFloat(timePercentage)
      },
      projections: this.calculateProjections(readsSaved, costSaved)
    };
  }
  
  calculateProjections(dailyReadsSaved, dailyCostSaved) {
    const usersPerDay = 1000; // Estimaci√≥n
    
    return {
      daily: {
        reads: dailyReadsSaved * usersPerDay,
        cost: (dailyCostSaved * usersPerDay).toFixed(2)
      },
      monthly: {
        reads: dailyReadsSaved * usersPerDay * 30,
        cost: (dailyCostSaved * usersPerDay * 30).toFixed(2)
      },
      yearly: {
        reads: dailyReadsSaved * usersPerDay * 365,
        cost: (dailyCostSaved * usersPerDay * 365).toFixed(2)
      }
    };
  }
}

// Funci√≥n principal
async function runOptimizationDemo() {
  console.log('üöÄ DEMOSTRACI√ìN DE OPTIMIZACIONES DE LECTURAS DE FIRESTORE');
  console.log('='.repeat(70));
  console.log('\nüìã Esta demostraci√≥n compara:');
  console.log('  ‚Ä¢ M√©todo tradicional: getDocs sin l√≠mites, sin cache');
  console.log('  ‚Ä¢ M√©todo optimizado: paginaci√≥n, getDoc, cache inteligente, precarga');
  
  const demo = new OptimizationDemo();
  
  try {
    // Ejecutar escenarios
    const traditionalResult = await demo.scenarioTraditional();
    await new Promise(resolve => setTimeout(resolve, 1000)); // Pausa
    const optimizedResult = await demo.scenarioOptimized();
    
    // Generar reporte comparativo
    const report = demo.generateComparisonReport(traditionalResult, optimizedResult);
    
    // Mostrar resultados
    console.log('\n' + '='.repeat(70));
    console.log('üìä REPORTE COMPARATIVO FINAL');
    console.log('='.repeat(70));
    
    console.log('\nüìà M√âTRICAS POR SESI√ìN:');
    console.log(`  M√©todo Tradicional: ${report.traditional.reads} lecturas, ${report.traditional.time}ms`);
    console.log(`  M√©todo Optimizado:  ${report.optimized.reads} lecturas, ${report.optimized.time}ms`);
    
    console.log('\nüí∞ AHORROS POR SESI√ìN:');
    console.log(`  üìä Lecturas: ${report.savings.reads} (${report.savings.readsPercentage}% menos)`);
    console.log(`  üíµ Costo: $${report.savings.cost.toFixed(4)} USD (${report.savings.costPercentage}% menos)`);
    console.log(`  ‚è±Ô∏è  Tiempo: ${report.savings.time}ms (${report.savings.timePercentage}% menos)`);
    
    console.log('\nüåç PROYECCIONES ESCALADAS (1000 usuarios/d√≠a):');
    console.log(`  üìÖ Diario: ${report.projections.daily.reads} lecturas, $${report.projections.daily.cost} USD`);
    console.log(`  üìÖ Mensual: ${report.projections.monthly.reads} lecturas, $${report.projections.monthly.cost} USD`);
    console.log(`  üìÖ Anual: ${report.projections.yearly.reads} lecturas, $${report.projections.yearly.cost} USD`);
    
    console.log('\nüéØ OPTIMIZACIONES IMPLEMENTADAS:');
    console.log('  ‚úÖ Paginaci√≥n real con Firestore (limit + startAfter)');
    console.log('  ‚úÖ Cache agresivo con localStorage y TTL');
    console.log('  ‚úÖ getDoc() en lugar de getDocs() para servicios individuales');
    console.log('  ‚úÖ Precarga inteligente de servicios populares');
    console.log('  ‚úÖ Analytics de comportamiento de usuario');
    console.log('  ‚úÖ Optimizaci√≥n de consultas en dashboard admin');
    
    // Guardar reporte
    fs.writeFileSync('optimization-demo-report.json', JSON.stringify(report, null, 2));
    console.log('\nüìÑ Reporte guardado en: optimization-demo-report.json');
    
    console.log('\n‚úÖ DEMOSTRACI√ìN COMPLETADA');
    console.log('\nüéâ Las optimizaciones implementadas reducen significativamente:');
    console.log('   ‚Ä¢ El consumo de lecturas de Firestore');
    console.log('   ‚Ä¢ Los costos operativos');
    console.log('   ‚Ä¢ Los tiempos de carga');
    console.log('   ‚Ä¢ La carga en el servidor');
    
  } catch (error) {
    console.error('‚ùå Error durante la demostraci√≥n:', error);
  }
}

// Ejecutar demostraci√≥n
if (require.main === module) {
  runOptimizationDemo();
}

module.exports = {
  runOptimizationDemo,
  OptimizationDemo,
  FirestoreSimulator,
  CacheSimulator
};